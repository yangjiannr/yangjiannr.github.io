<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="makefile,make,GCC,C/CPP," />










<meta name="description" content="makefile及make简介概念引入在介绍makefile和make的具体概念之前，我们通过一个例子来说明Makefile和make到底是是为解决说明问题而存在的。假设有一个如图所示的C工程：那么要编译出我们的可执行程序project_demo，必须执行以下命令： 12345678910111213# 步骤1：编译主程序模块$ gcc -o &amp;lt;100个主程序模块的o文件&amp;gt; -c &amp;l">
<meta name="keywords" content="makefile,make,GCC,C&#x2F;CPP">
<meta property="og:type" content="article">
<meta property="og:title" content="学习makefile记录">
<meta property="og:url" content="http://yoursite.com/2018/07/13/学习makefile记录/index.html">
<meta property="og:site_name" content="紫魔戒的博客">
<meta property="og:description" content="makefile及make简介概念引入在介绍makefile和make的具体概念之前，我们通过一个例子来说明Makefile和make到底是是为解决说明问题而存在的。假设有一个如图所示的C工程：那么要编译出我们的可执行程序project_demo，必须执行以下命令： 12345678910111213# 步骤1：编译主程序模块$ gcc -o &amp;lt;100个主程序模块的o文件&amp;gt; -c &amp;l">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://image.yangjiannr.cn/20180509wm.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180510wm1.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180510wm2.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180510wm3.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180511makefile_simple.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180511makefile_complicated.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180522functionclassify.png">
<meta property="og:image" content="http://image.yangjiannr.cn/20180522headerDependent.png">
<meta property="og:updated_time" content="2018-07-13T12:46:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习makefile记录">
<meta name="twitter:description" content="makefile及make简介概念引入在介绍makefile和make的具体概念之前，我们通过一个例子来说明Makefile和make到底是是为解决说明问题而存在的。假设有一个如图所示的C工程：那么要编译出我们的可执行程序project_demo，必须执行以下命令： 12345678910111213# 步骤1：编译主程序模块$ gcc -o &amp;lt;100个主程序模块的o文件&amp;gt; -c &amp;l">
<meta name="twitter:image" content="http://image.yangjiannr.cn/20180509wm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/13/学习makefile记录/"/>





  <title>学习makefile记录 | 紫魔戒的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">紫魔戒的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/13/学习makefile记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frank yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://image.yangjiannr.cn/20180912avator.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="紫魔戒的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学习makefile记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-13T20:46:25+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          


          
            <span class="post-meta-divider">|</span>
            <span id="busuanzi_value_page_pv"></span>次阅读
          

          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="makefile及make简介"><a href="#makefile及make简介" class="headerlink" title="makefile及make简介"></a>makefile及make简介</h1><h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在介绍makefile和make的具体概念之前，我们通过一个例子来说明Makefile和make到底是是为解决说明问题而存在的。<br>假设有一个如图所示的C工程：<br><img src="http://image.yangjiannr.cn/20180509wm.png" alt="C工程"><br>那么要编译出我们的可执行程序project_demo，必须执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 步骤1：编译主程序模块</span><br><span class="line">$ gcc -o &lt;100个主程序模块的o文件&gt; -c &lt;100个主程序没模块的c文件&gt;</span><br><span class="line"></span><br><span class="line"># 步骤2：编译功能模块a</span><br><span class="line">$ gcc -o &lt;1000个功能模块a的o文件&gt; -c &lt;1000个功能模块a的c文件&gt;</span><br><span class="line">$ ar rcs liba.a &lt;1000个功能模块a的o文件&gt;</span><br><span class="line"></span><br><span class="line"># 步骤3：编译功能模块b</span><br><span class="line">$ gcc -o &lt;1000个功能模块b的o文件&gt; -c &lt;1000个功能模块b的c文件&gt;</span><br><span class="line">$ ar rcs libb.a &lt;1000个功能模块b的o文件&gt;</span><br><span class="line"></span><br><span class="line"># 步骤4：生成可执行文件demo</span><br><span class="line">$gcc -o demo &lt;100个主程序模块的o文件&gt; -L. -la -lb</span><br></pre></td></tr></table></figure>
<p>make和Makefile的存在正式为了解决上述两个问题的：</p>
<ol>
<li>makefile文件帮助我们记录了整个项目工程的所有需要编译的文件列表，这样我们在编译时仅需要输入简单的make命令就能编译出我们期望的结果；</li>
<li>makefile文件反映了整个项目中各个模块的依赖关系，这样我们改动了某些源文件后，仅需简单的输入make命令，make工具就会根据makefile文件里描述的依赖关系帮助我们分析哪些模块需要重新编译，并执行相应的操作。</li>
</ol>
<p>在linux/unix开发环境中，makefile文件则是描述一个特定编译系统所需要的策略，而make工具则是通过解析makefile文件并执行相应的命令来帮助我们构建其编译系统。</p>
<p>下面我们就带着这两个问题来认识makefile和make工具：</p>
<ol>
<li>makefile文件如何记录整个项目工程的所有需要编译的文件列表及如何反应整个项目中各个模块的依赖关系？</li>
<li>提供了makefile策略描述后，make工具有事如何解析makefile文件来帮助我们构建其编译系统的？</li>
</ol>
<a id="more"></a>
<h3 id="makefile简介"><a href="#makefile简介" class="headerlink" title="makefile简介"></a>makefile简介</h3><p>makefile就是一个简单的文本文件，它基本上就是由一条条的规则构成。下面，我们就来看一下makefile里的最基本的语法单元，规则。<br>一条makefile的规则构成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taget: prerequisites</span><br><span class="line">&lt;tab&gt; command1</span><br><span class="line">&lt;tab&gt; command2</span><br><span class="line">......</span><br><span class="line">&lt;tab&gt; commandN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>target: 规则的目标，可以简单理解为这条规则存在的目的是什么。通常是程序中间或者最后需要生成的文件名，也可以不对具体的文件，而仅仅就是个概念上的规则目标。<br>prerequisites：规则的依赖列表，可以简单的理解为要达到本条规则的目标所需要的先决条件是什么。可以是文件名，也可以是其它规则的目标；<br>command：规则的命令，可以简单的理解为当目标所需要的先决条件满足之后，需要执行什么动作来达成规则的目标。规则的命令其实就是shell命令。一条规则中可以有多行命令，特别注意：<strong>每行命令都必须以tab键开始！</strong></p>
</blockquote>
<p>下面我们就立马来感性的认识一下makefile文件，先来一个“hello world”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 最简单的makefile文件</span><br><span class="line">all:</span><br><span class="line">    echo &quot;hello world!&quot;  # 注意：每行命令都必须以tab键开始！</span><br></pre></td></tr></table></figure>
<p>这个简单的makefile文件只有一条规则，规则的目标是all，没有任何依赖（规则不可以没有目标但是可以没有依赖），以及一条命令（其实规则也是可以不需要任何命令的）</p>
<p>怎么用这个makefile呢？<br>命令行中执行 <code>$ make</code>命令</p>
<h3 id="make命令工作机理"><a href="#make命令工作机理" class="headerlink" title="make命令工作机理"></a>make命令工作机理</h3><p>make命令的基本使用规范如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make [ -f makefile ] [ option ] ... [ targets ] ...</span><br></pre></td></tr></table></figure>
<ol>
<li>不带任何参数，直接执行make</li>
<li>指定makefile文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -f &lt;makefile_name&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指定makefile目标：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make &lt;target&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>到指定目录下执行make</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -C &lt;subdir&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure>
<p>在执行make的时候，我们可以带上’-f &lt;文件名&gt;’参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下一次查找名字为<strong>GNUmakefile, makefile 和 Makefile</strong>的文件来作为其makefile文件。</p>
<p>在读取完makefile的内容后，make工具并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。而这条作为突破口的规则的目标，称为终极目标，我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。</p>
<p>一般情况下，make执行一条规则的具体过程是这样的：<br><img src="http://image.yangjiannr.cn/20180510wm1.png" alt="make规则"></p>
<p>假设有makefile内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">终极目标：依赖A 依赖B 依赖C</span><br><span class="line">    终极目标命令</span><br><span class="line"></span><br><span class="line">依赖B: 子依赖B1 子依赖B2</span><br><span class="line">    依赖B命令</span><br><span class="line"></span><br><span class="line">依赖C: 子依赖C1 子依赖C2</span><br><span class="line">    依赖C命令</span><br><span class="line"></span><br><span class="line">依赖A: 子依赖A1 子依赖A2</span><br><span class="line">    依赖A命令</span><br></pre></td></tr></table></figure>
<ol>
<li><p>以终极目标为树根，解析出整颗依赖树：<br><img src="http://image.yangjiannr.cn/20180510wm2.png" alt="终极目标1"></p>
</li>
<li><p>对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则：<br><img src="http://image.yangjiannr.cn/20180510wm3.png" alt="终极目标2"></p>
</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="简单实例："><a href="#简单实例：" class="headerlink" title="简单实例："></a>简单实例：</h3><p>project_simple<br> |– main.c<br> |– Makefile<br> |– simple.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is simple project!\n"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写makefile之前都需要先分析清楚整个工程各个模块的依赖关系，以及相应的生成命令。<br>project_simple工程最终产生的是一个simple的可执行文件，而该可执行文件是使用gcc命令编译main.c和simple.c生成的，因此整个工程的关系依赖图，如下：<br><img src="http://image.yangjiannr.cn/20180511makefile_simple.png" alt="关系依赖图"><br>因此makefile可以如下写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simple: main.c simple.c</span><br><span class="line">    gcc -o simple main.c simple.c</span><br></pre></td></tr></table></figure>
<p>执行<code>$ make</code>命令，于是生成simple文件，运行<code>$ ./simple</code></p>
<h3 id="复杂实例"><a href="#复杂实例" class="headerlink" title="复杂实例"></a>复杂实例</h3><p>project_complicated<br> |– complicated.c<br> |– complicated.h<br> |– main.c<br> |– Makefile</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complicated.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"%s\n"</span>, HELLO_STRING);</span><br><span class="line">    complicated();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// complictead.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMOLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_STRING <span class="meta-string">"Hello !"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_NAME <span class="meta-string">"complicated"</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comlicated.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complicated.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is a %s project!\n"</span>, PROJECT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目依赖关系图：<br><img src="http://image.yangjiannr.cn/20180511makefile_complicated.png" alt="依赖关系图"></p>
<p><strong>精确的分析清楚项目的依赖关系，是编写一个好的makefile的关键</strong></p>
<p>complicated的makefile如下（加注释可以提升可维护性）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 终极目标规则，生成complicated可执行文件</span><br><span class="line">complicated: main.o complicated.o</span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"># 子规则1，main.o的生成规则</span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"># 子规则2，complicated.o的生成规则</span><br><span class="line">complicated.o: complicated.c</span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>makefile中的变量，与C语言中的宏类似，<code>变量名 赋值符 变量值</code></p>
<blockquote>
<p>变量名不包括“:”、“#”、“=”、前置空白和尾空白的任何字符串。<br>变量名是大小写敏感的。Makefile传统是变量名是全采用大写的方式。<br>推荐做法是对于内部定义的一般变量（如：目标文件列表objects）使用小写方式，而对于一些参数列表（如：编译选项CFLAGS）采用大写方式。<br>变量的值，其本质就是一个字符串<br>赋值符有=、:=、?=、+=四种格式，其中=和:=为基本定义类型，?=和+=为基于=的扩展定义类型。<br>例：<code>objects = program.o foo.o util.o</code></p>
</blockquote>
<h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><ol>
<li><code>${变量名}</code></li>
<li><code>(变量名)</code></li>
<li><code>$单字符变量名</code>，变量名仅包含一个字符，如<code>$@</code>, <code>$^</code>等<br>makefile中引用变量的例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 变量定义</span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line"># 在依赖中、命令中引用变量</span><br><span class="line">program: $(objects)</span><br><span class="line">    gcc -o program $(objects)</span><br><span class="line"></span><br><span class="line"># 在目标中引用变量</span><br><span class="line">$(objects): defs.h</span><br></pre></td></tr></table></figure>
<h3 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h3><p>所谓自动化变量，就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量，常用的有：<br><code>$@</code> – 代表规则中的目标文件<br><code>$&lt;</code> – 代表规则中第一个依赖的文件名<br><code>$^</code> – 代表规则中所有依赖文件的列表，文件名用空格分隔</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all: first second third</span><br><span class="line">    echo &quot;\$$@ = $@&quot;</span><br><span class="line">    echo &quot;$$&lt; = $&lt;&quot;</span><br><span class="line">    echo &quot;$$^ = $^&quot;</span><br><span class="line"></span><br><span class="line">first second third:</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>$</code>字符在Makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给echo命令执行，需要使用<code>$$</code><br><code>$@</code>在bash shell中也有特殊用途，因此如果想echo命令在bash中正常输出<code>$@</code>，需要加上\字符<br>该makefile的最后一行<code>first second third:</code>看起来有点奇怪，这是一条没有依赖和命令的多目标规则</p>
</blockquote>
<h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><p>“替换引用”<code>$(VAR:A=B)</code>或者<code>{VAR:A=B}</code>，意思是，“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其他部分的“A”字符不进行替换，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources := a.c b.c c.c d.d</span><br><span class="line">objects := $(source:.c=.o)</span><br><span class="line">all:</span><br><span class="line">    echo &quot;objects = $(objects)&quot;</span><br></pre></td></tr></table></figure>
<p>在这个定义中，变量“objects”的值就为“a.c b.c c.c d.d”，使用变量的替换引用将变量“sources”以空格分开的值中所有以.c结尾的字符替换为.o，其他部分不变。</p>
<p>更新为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 定义可执行文件变量</span><br><span class="line">executable := complicated</span><br><span class="line"># 定义源文件列表变量</span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"># 使用变量的引用替换，定义object文件列表</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"># 定义编译命令变量</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"># 终极目标规则，生成complicated可执行文件</span><br><span class="line">$(executable): $(objects)</span><br><span class="line"># 使用自动化变量改造我们的编译指令</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line"># 子规则1，main.o的生成规则</span><br><span class="line">main.o: main.c</span><br><span class="line">    $(CC) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line"># 子规则2，complicated.o的生成规则</span><br><span class="line">complicated.o: complicated.c</span><br><span class="line">    $(CC) -o $@ -c $&lt;</span><br></pre></td></tr></table></figure>
<h3 id="多目标规则"><a href="#多目标规则" class="headerlink" title="多目标规则"></a>多目标规则</h3><p>一种将多条具有 1）相同依赖 2）相同生成命令的规则，合并成一条规则的语法，其基本格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target...: prerequisites...</span><br><span class="line">	commands</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>假设我们有以下makefile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">all: target1 target2</span><br><span class="line">	echo &quot;This is a rule for $@&quot;</span><br><span class="line">	</span><br><span class="line">target1: dep</span><br><span class="line">	echo &quot;This is a rule for $@&quot;</span><br><span class="line">	</span><br><span class="line">target2: dep</span><br><span class="line">	echo &quot;This is a rule for $@&quot;</span><br><span class="line">	</span><br><span class="line">dep:</span><br></pre></td></tr></table></figure>
<p>利用多目标规则，可以将makefile改写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all: target1 target2</span><br><span class="line">	echo &quot;This is a rule for $@&quot;</span><br><span class="line">	</span><br><span class="line"># 利用多目标规则和并target1 和 target2的规则</span><br><span class="line">target1 target2: dep</span><br><span class="line">	echo &quot;This is a rule for $@&quot;</span><br><span class="line">	</span><br><span class="line">dep:</span><br></pre></td></tr></table></figure>
<h3 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h3><p>makefile中，一个目标可以同时出现在多条规则中。这种情况下，此目标文件的所有依赖文件将被合并成此目标一个依赖文件列表，其中任何一个依赖文件比目标更新（比较目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目标。对于一个多规则的目标，重建此目标的命令只能出现在一个规则中（可以是多条命令）。如果多个规则同时给出重建此目标的命令，make将使用最后一个规则的命令，同时提示错误信息。</p>
<h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>静态模式规则，可以理解为一种特殊的多目标规则，它仅要求多条规则具有相同的命令，而依赖可以完全不一样。</p>
<p>静态模式规则，其基本语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TARGETS ...: TARGET_PATTERN: PREREQ-PATTERNS ...</span><br><span class="line">	COMMANDS</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>其大致意思是，用<code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>描述的模式，从<code>TARGETS ...</code>取值来形成一条条规则，所有规则的命令都用<code>COMMANDS</code>。</p>
<p><code>TARGETS ...</code>代表具有相同模式的规则的目标列表，在我们的项目中就是main.o和complicated.o，我们可以直接引用我们先前定义的objects变量。</p>
<p><code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>部分定义了，如何为目标列表中的目标，生成依赖；<code>TARGET-PATTERN</code>称为目标模式，<code>PREREQ-PATTERNS</code>称为依赖模式；目标模式和依赖模式中，一般需要包含模式字符<code>%</code>。</p>
<p>目标模式的作用就是从目标列表中的目标匹配过滤出需要的值，目标模式中的字符<code>%</code>表示在匹配过滤的过程中不做过滤的部分，目标模式中的其他字符表示要与目标列表中的目标精确匹配，例如，目标模式<code>%.o</code>， 表示从目标列表的目标中匹配所有已<code>.o</code>结尾的目标，然后过滤掉匹配目标的<code>.o</code>部分， 因此目标<code>main.o</code>经过目标模式<code>%.o</code>匹配过滤后，得到的输出就是<code>main</code>。</p>
<p>依赖模式的作用就是表示要如何生成依赖文件。具体的生成过程，就是使用目标模式过滤出来的值，替换依赖模式字符<code>%</code>所表示的位置。因此，如果依赖模式为<code>%.c</code>， 则使用上述例子过滤出来的<code>main</code>来替换字符<code>%</code>， 最终得到依赖文件main.c</p>
<p>因此，我们可以这么用静态模式规则来简化我们的complicated项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 静态模式规则简化complicated makefile</span><br><span class="line">$(object): %.o: %.c</span><br><span class="line">	$(CC) -o $@ -c $&lt;</span><br></pre></td></tr></table></figure>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>我们的complicated项目编译完成后，会有可执行文件及中间目标文件，有时出于某些需求，需要将编译生成的文件都删除，让整个项目回到最初的状态。我们可以在该项目makefile定义添加一条目标为<code>clean</code>的规则，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># complicated项目添加clean规则</span><br><span class="line">clean:</span><br><span class="line">	rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure>
<p>上述的clean规则，貌似能正常工作，但其实是存在bug的，当我们的目录下刚好存在一个叫做clean的文件时，事情就没那么顺利了。</p>
<p>出现以上问题的原因是，当编译目录下存在clean文件时，由于clean规则没有依赖，所以clean文件的时间戳永远显得都是最新的，故其命令也无法被执行，这时我们就得请伪目标出手帮助了。</p>
<p>当我们将一个目标定义成伪目标时，意味着它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。</p>
<p>定义一个伪目标的基本语法：<br><code>.PHONY: &lt;伪目标&gt;</code></p>
<p>因此我们以定义complicated项目的clean目标，为伪目标，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># complicated项目添加clean 规则</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure>
<p>这样目标<code>clean</code>就是一个伪目标，无论当前目录下是否存在<code>clean</code>这个文件。我们输入<code>make clean</code>之后。<code>rm</code>命令都会被执行。</p>
<h2 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h2><p>make的内嵌函数为我们提供了处理文件名、变量、文本和命令的方法。使我们的makefile更为灵活和健壮。我们可以在需要的地方调用函数来处理指定的文本（参数），函数在调用它的地方被替换为它的处理结果。函数调用（引用）的展开和变量引用的展开方式类似：<br>函数调用方式1：<code>$(FUNCTION ARGUMENTS)</code><br>函数调用方式2：<code>${FUNCTION ARGUMENTS}</code></p>
<h3 id="内嵌函数分类"><a href="#内嵌函数分类" class="headerlink" title="内嵌函数分类"></a>内嵌函数分类</h3><p><img src="http://image.yangjiannr.cn/20180522functionclassify.png" alt="内嵌函数分类"></p>
<h3 id="使用wildcard函数改进"><a href="#使用wildcard函数改进" class="headerlink" title="使用wildcard函数改进"></a>使用wildcard函数改进</h3><p>wildcard函数，其使用范式：<code>$(wildcard PATTERN)</code><br>函数名称：wildcard<br>函数功能：列出当前目录下所有符合模式“PATTERN”格式的文件名<br>返回值：空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名<br>函数说明：“PATTERN”使用shell可识别的通配符，包括？（单字符）、<em>（多字符）等。<br>例：`$(wildcard </em>.c)`返回值为当前目录下所有.c源文件列表</p>
<p>我们可以引进wildcard函数，改进complicated项目的makefile，使其能够自动扫描当前目录下的源文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 定义可执行文件变量</span><br><span class="line">executbale := complicated</span><br><span class="line"># 引进wildcard函数扫描源文件，定义列表变量</span><br><span class="line">sources := $(wildcard *.c)</span><br><span class="line"># 使用变量的引用替换，定义object文件列表</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"># 定义编译命令变量</span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"># 终极目标规则，生成complicated可执行文件</span><br><span class="line">$(executbale): $(objects)</span><br><span class="line">#  使用自动化变量改造我们的编译命令</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span><br><span class="line">$(objects):%.o:%.c</span><br><span class="line">    $(CC) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line"># clean规则</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    $(RM) $(executbale) $(objects)</span><br></pre></td></tr></table></figure></p>
<h2 id="自动生成依赖关系"><a href="#自动生成依赖关系" class="headerlink" title="自动生成依赖关系"></a>自动生成依赖关系</h2><p>存在一个问题，当我们更新头文件complicated.h的内容后，执行make时，项目并不会重新编译。出现此问题的根本原因是，我们的makefile还没能精确的反映整个项目工程的依赖关系。很明显，项目的依赖关系应该加入对于头文件的依赖关系，即如下图：<br><img src="http://image.yangjiannr.cn/20180522headerDependent.png" alt=""><br>根据上述依赖关系，我们可以在makefile加上如下规则：<code>$(object): complicated.h</code></p>
<p>上述规则加入虽然能解决我们的问题，但是对于大型复杂的项目，这种需要我们逐个去分析头文件被依赖的关系，几乎是不可能的。所以我们需要工具来帮我们做这个事。下面我们来介绍如何实现自动生成依赖关系。</p>
<p>gcc为我们提供了这样的功能，帮助我们分析一个文件对其他文件的依赖关系列表。当我们在执行gcc时带上<code>-MM</code>选项时，gcc工具就会为我们列出指定文件对其他文件的依赖关系列表。</p>
<p>接下来要考虑的问题就是如何将gcc的输出导入到我们的makefile中了。<br>makefile支持使用<code>sinclude</code>关键字将指定文件导入到当前的makefile当中，它的作用与C语言的<code>#inlucde</code>预处理命令是一样的。使用方式<code>sinclude &lt;other_makefiles&gt;</code>。因此，我们可以将gcc对于源文件的依赖关系分析输出到某个文件(我们可以称为依赖描述文件，一般命名为与源文件同名但以.d结尾的文件)当中，然后再将依赖描述文件导入到makefile中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用变量的引用替换，定义依赖描述文件列表</span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"># 导入依赖描述文件列表</span><br><span class="line">sinclude $(deps)</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>sinclude</code>关键字向当前makefile导入文件时，如果所导入的文件不存在，make会试图去执行可以生产导入文件的规则去生产被导入的文件，然后再执行导入。因此我们可以使用静态模式规则，让make在执行时，去调用gcc生成依赖关系文件，我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(deps):%.d:%.c</span><br><span class="line">	gcc -MM $&lt; &gt; $@</span><br></pre></td></tr></table></figure>
<p>因此，我们complicated项目的最终makefile可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 定义可执行文件变量</span><br><span class="line">executbale := complicated</span><br><span class="line"># wildcard函数扫描源文件，定义列表变量</span><br><span class="line">sources := $(wildcard *.c)</span><br><span class="line"># 使用变量的引用替换，定义object文件列表</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"># 使用变量的引用替换，定义依赖描述文件列表</span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"># 定义编译命令变量</span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"># 终极目标规则，生成complicated可执行文件</span><br><span class="line">$(executbale): $(objects)</span><br><span class="line">#  使用自动化变量改造我们的编译命令</span><br><span class="line">    $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span><br><span class="line">$(objects):%.o:%.c</span><br><span class="line">    $(CC) -o $@  -c $&lt;</span><br><span class="line"></span><br><span class="line"># clean规则</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    $(RM) $(executbale) $(objects) $(deps)</span><br><span class="line"></span><br><span class="line"># 自动规则依赖</span><br><span class="line">sinclude $(deps)</span><br><span class="line"></span><br><span class="line">$(deps):%.d:%.c</span><br><span class="line">    $(CC) -MM $&lt; &gt; $@</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/makefile/" rel="tag"># makefile</a>
          
            <a href="/tags/make/" rel="tag"># make</a>
          
            <a href="/tags/GCC/" rel="tag"># GCC</a>
          
            <a href="/tags/C-CPP/" rel="tag"># C/CPP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/07/eclipse代码补全按键修改成Tab/" rel="next" title="eclipse代码补全按键修改成Tab">
                <i class="fa fa-chevron-left"></i> eclipse代码补全按键修改成Tab
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/31/Hadoop参数配置详解/" rel="prev" title="Hadoop参数配置 详解">
                Hadoop参数配置 详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://image.yangjiannr.cn/20180912avator.jpg"
                alt="Frank yang" />
            
              <p class="site-author-name" itemprop="name">Frank yang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#makefile及make简介"><span class="nav-number">1.</span> <span class="nav-text">makefile及make简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念引入"><span class="nav-number">1.0.1.</span> <span class="nav-text">概念引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile简介"><span class="nav-number">1.0.2.</span> <span class="nav-text">makefile简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make命令工作机理"><span class="nav-number">1.0.3.</span> <span class="nav-text">make命令工作机理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例"><span class="nav-number">1.1.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单实例："><span class="nav-number">1.1.1.</span> <span class="nav-text">简单实例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂实例"><span class="nav-number">1.1.2.</span> <span class="nav-text">复杂实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的使用"><span class="nav-number">1.2.</span> <span class="nav-text">变量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的引用"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的变量"><span class="nav-number">1.2.3.</span> <span class="nav-text">特殊的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的替换引用"><span class="nav-number">1.2.4.</span> <span class="nav-text">变量的替换引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多目标规则"><span class="nav-number">1.2.5.</span> <span class="nav-text">多目标规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多规则目标"><span class="nav-number">1.2.6.</span> <span class="nav-text">多规则目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态模式规则"><span class="nav-number">1.2.7.</span> <span class="nav-text">静态模式规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪目标"><span class="nav-number">1.2.8.</span> <span class="nav-text">伪目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内嵌函数"><span class="nav-number">1.3.</span> <span class="nav-text">内嵌函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内嵌函数分类"><span class="nav-number">1.3.1.</span> <span class="nav-text">内嵌函数分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用wildcard函数改进"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用wildcard函数改进</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动生成依赖关系"><span class="nav-number">1.4.</span> <span class="nav-text">自动生成依赖关系</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank yang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
